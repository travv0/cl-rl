(in-package #:rl)

(define-class enemy (alive solid visible)
  ((%enemy-state :initarg :enemy-state
                 :initform :sleeping
                 :accessor enemy-state)
   (%wandering-to :initform (random-pos)
                  :accessor wandering-to)
   (%view-distance :initform 10 :initarg :view-distance :accessor view-distance)))

(define-class goblin (enemy humanoid)
  ((%stamina :initform 5)
   (%resistances :initform (list (make-resistance 'fire 0.8)))
   (%strength :initform 3)
   (%dexterity :initform 2)
   (%endurance :initform 5)
   (%resistance :initform 1)
   (%intelligence :initform 1)
   (%faith :initform 1)
   (%vitality :initform 3)))

(define-class goblin-fighter (goblin)
  ((%inventory :initform (make-inventory (make-instance 'dagger)))))

(define-class goblin-brawler (goblin)
  ((%strength :initform 10)
   (%vitality :initform 10)))

(define-class warrior (enemy humanoid)
  ((%strength :initform 10)
   (%dexterity :initform 5)
   (%endurance :initform 10)
   (%vitality :initform 10)
   (%resistance :initform 5)
   (%intelligence :initform 1)
   (%faith :initform 10)
   (%inventory :initform (make-inventory (make-instance 'sword)
                                         (make-instance 'kite-shield)))))

(define-class rat (enemy)
  ((%strength :initform 2)
   (%dexterity :initform 2)
   (%endurance :initform 2)
   (%vitality :initform 2)))

(defmethod print-object ((enemy enemy) stream)
  (print-unreadable-object (enemy stream :type t :identity t)
    (format stream "(~d, ~d) ~s" (x enemy) (y enemy) (enemy-state enemy))))

(defmethod update ((enemy enemy))
  (ccase (enemy-state enemy)
    (:chasing (cond ((and (zerop (random 50))
                          (not (can-see-p enemy *player*)))
                     (setf (enemy-state enemy) :wandering))
                    ((< (stamina enemy) (attack-stamina-use enemy))
                     (setf (enemy-state enemy) :fleeing))
                    (t (move-toward-goal enemy *player*))))
    (:wandering
     (move-toward-goal enemy (wandering-to enemy))
     (cond ((and (< (random 5) 4)
                 (< (distance enemy *player*) (view-distance enemy))
                 (can-see-p enemy *player*))
            (setf (enemy-state enemy) :chasing))
           ((and (zerop (dx enemy)) (zerop (dy enemy)))
            (setf (wandering-to enemy) (random-pos)))))
    (:sleeping (when (and (zerop (random 5))
                          (< (distance enemy *player*) (view-distance enemy))
                          (can-see-p enemy *player*))
                 (setf (enemy-state enemy) :chasing)))
    (:fleeing
     (loop for moved = (move-toward-goal enemy (wandering-to enemy))
           for i from 1
           do (setf (wandering-to enemy) (random-pos))
           until (or moved (> i 5)))
     (when (and (>= (stamina enemy) (* 1.5 (attack-stamina-use enemy)))
                (zerop (random 20)))
       (setf (enemy-state enemy) :chasing)))))
