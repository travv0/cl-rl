(in-package #:rl)

(defclass enemy (alive solid visible)
  ((%enemy-state :initarg :enemy-state
                 :initform (if (zerop (random 2))
                               :wandering
                               :sleeping)
                 :accessor enemy-state)
   (%wandering-to :initform (random-pos)
                  :accessor wandering-to)
   (%view-distance :initform 30 :initarg :view-distance :accessor view-distance)))

(defclass goblin (enemy humanoid)
  ((%stamina :initform 40)
   (%resistances :initform (list (make-resistance 'fire 0.8)))
   (%strength :initform 3)
   (%dexterity :initform 2)
   (%endurance :initform 5)
   (%vitality :initform 3)))

(defclass goblin-fighter (goblin)
  ((%equip-right-arm :initform (make-instance 'dagger))))

(defclass warrior (enemy humanoid)
  ((%equip-right-arm :initform (make-instance 'sword))
   (%equip-left-arm :initform (make-instance 'kite-shield))
   (%strength :initform 5)
   (%dexterity :initform 5)
   (%endurance :initform 5)
   (%vitality :initform 5)))

(defclass rat (enemy)
  ((%strength :initform 2)
   (%dexterity :initform 2)
   (%endurance :initform 2)
   (%vitality :initform 2)))

(defmethod print-object ((enemy enemy) stream)
  (print-unreadable-object (enemy stream :type t :identity t)
    (format stream "(~d, ~d) ~s" (x enemy) (y enemy) (enemy-state enemy))))

(defmethod update ((enemy enemy))
  (ccase (enemy-state enemy)
    (:chasing (cond ((and (zerop (random 50))
                          (not (can-see-p enemy *player*)))
                     (setf (enemy-state enemy) :wandering))
                    ((< (stamina enemy) (stamina-use enemy))
                     (setf (enemy-state enemy) :fleeing))
                    (t (when (and (equip-left-arm enemy) (typep (equip-left-arm enemy) 'shield)
                                  (or (> (distance enemy *player*) 1)
                                      (zerop (random 10))))
                         (raise-shield enemy))
                       (move-toward-goal enemy *player*))))
    (:wandering
     (lower-shield enemy)
     (move-toward-goal enemy (wandering-to enemy))
     (cond ((and (< (random 5) 4)
                 (< (distance enemy *player*) (view-distance enemy))
                 (can-see-p enemy *player*))
            (setf (enemy-state enemy) :chasing))
           ((and (zerop (dx enemy)) (zerop (dy enemy)))
            (setf (wandering-to enemy) (random-pos)))))
    (:sleeping (when (and (zerop (random 5))
                          (< (distance enemy *player*) (view-distance enemy))
                          (can-see-p enemy *player*))
                 (setf (enemy-state enemy) :chasing)))
    (:fleeing
     (lower-shield enemy)
     (loop for moved = (move-toward-goal enemy (wandering-to enemy))
           for i from 1
           do (setf (wandering-to enemy) (random-pos))
           until (or moved (> i 5)))
     (when (and (>= (stamina enemy) (* 1.5 (stamina-use enemy)))
                (zerop (random 20)))
       (setf (enemy-state enemy) :chasing)))))
